# sum_of_integers
Ζητούμενο
=========
Το ζητούμενο της εργασίας είναι να υλοποιήσετε ένα πρόγραμμα σε συμβολική γλώσσα για τον προσομοιωτή
WinMIPS64 με σκοπό την εκτέλεσή του στον μικρότερο δυνατό χρόνο (μικρότερο αριθμό κύκλων ρολογιού).
Το πρόγραμμα πρέπει να εκτελεί την εξής απλή λειτουργία: υπολογίζει το άθροισμα των 500 στοιχείων ενός πίνακα
απρόσημων (unsigned) ακεραίων αριθμών Κ[i] (i = 0, 1, ... 499) που βρίσκονται στην μνήμη (στο τμήμα .data του
πηγαίου αρχείου συμβολικής γλώσσας). Οι αριθμοί K[i] έχουν τιμές μεταξύ του 0 και του 127, ο πίνακας δεν είναι
ταξινομημένος και οποιαδήποτε τιμή μπορεί να εμφανίζεται οποιονδήποτε αριθμό φορών. Στο τέλος της εκτέλεσης
του προγράμματος να εκτυπώνεται στο Terminal το άθροισμα: “Sum=...”.

Τεκμηρίωση
==========
Αρχικά φορτώνονται στον r4 και r5 οι 16 πρώτοι αριθμοί του πίνακα (8+8) και αθροίζονται στον καταχωρητή
r6. Στη συνέχεια “αφαιρούμε” από το άθροισμα το 8ο bit κάθε αριθμού με τη χρήση μιας μάσκας και το κρατάμε
στον r18. Άρα κάθε αριθμός που υπάρχει στον r6 είναι μέχρι το 127 επομένως “χωράει” σε 7 bit, κάθε φορά
λοιπόν που προσθέτουμε τους επόμενους 8 αριθμούς στον r6 αφαιρούμε το 8ο bit, το οποίο κρατιέται αρχικά
στον r18 και μετά προστίθεται στον r19, και έτσι εξασφαλίζουμε ότι δεν θα υπάρξει περίπτωση υπερχείλισης,
ενώ στον r19 κρατάμε τον αριθμό των φορών που φτάσαμε στο 128.
Έπειτα μετά την έξοδο από το loop όπου υπολογίστηκε το άθροισμα των πρώτων 496 αριθμών (8*62)
ανακτούμε από τον r6 τους 8 αριθμούς που περιέχει με τη βοήθεια μασκών και srl και του προσθέτουμε στο r7,
ενώ αθροίζουμε και τους 4 τελευταίους αριθμούς.
Τέλος κάνουμε το ίδιο και με τους αριθμούς από τον καταχωρητή r19 τους οποίους όμως πριν προσθέσουμε στο
r7 πολλαπλασιάζουμε λογικά με το 128 κάνοντας sll κάτα 7 bit.

Λογική εκτέλεσης πράξεων
===========
r4 (για ευκολία φαίνονται μόνο τα 8 τελευταία bit από τα 64)

0 1 0 0 1 1 1 0

r5 ή r6 μέσα στο loop

0 1 0 1 1 1 0 0

r6 (r4+r5 ή r4+r6)

1 0 1 0 1 0 1 0

Μετά γίνεται το “σπάσιμο” σε r6 και r18

r6

0 0 1 0 1 0 1 0

r18

1 0 0 0 0 0 0 0

r18 (το κάνουμε srl με offset 7)

0 0 0 0 0 0 0 1

r19 (r19+r18, έστω ότι είχε από πριν την τιμή 00000101)

0 0 0 0 0 1 1 0


Επομένως, έχουμε 8 αριθμούς στον r6 και άλλους 8 στον r19, οι οποίοι αντιστοιχούν στις φορές που φτάσαμε στο
128. Όπου στο τέλος προσθέτουτουμε τους 8,8bitους αριθμόυς που υπάρχουν στον r6 και τους άλλους 8 αριθμούς
που υπάρχουν στον r19 αφου κάναμε τον πολλαπλασιασμό με το 128.

Για την επιτάχυνση του πραγράμματος μας χρησιμοποιήσαμε και την τεχνική του unroll στον βρόχο μας για να
γλιτώσουμε κύκλους ρολογιού.
